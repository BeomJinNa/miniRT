# 프로젝트 개념 요약

### **워크플로우**

1. **기본 레이 트레이서 구조 구축:**
   - 카메라, 광선, 센서와 같은 기본 개체 및 데이터 구조 정의
   - 광선 발사 및 감지 함수 구현

2. **객체 및 장면 설정:**
   - 다양한 기하학적 형태(구, 평면, 원통 등)를 위한 데이터 구조와 충돌 감지 함수 구현
   - 장면 설정을 위한 파일 파서 구현 (객체, 광원, 카메라의 위치 및 속성 등)

3. **렌더링 및 색상 처리:**
   - 부딪힌 광선의 색상 값을 계산하는 함수 구현 (반사, 굴절, 그림자 처리 포함)
   - 몬테 카를로 방법을 사용한 Adaptive Sampling 구현하여 노이즈 감소

4. **최적화:**
   - BVH를 구현하여 레이-객체 충돌 체크 속도 향상

5. **후처리:**
   - Tone Mapping 구현하여 최종 이미지의 색상 범위를 조정


### **프로그램 구조**
```plain text
+──────────────────────────────────────────+
│                Main                      │
│   - Configuration Loader                 │
│   - Scene Initialization                 │
│   - Raytracing Process Manager           │
+─────┴────────────────────────────────────+
      │
      ▼
+─────┴──────────────────────────────────────────────────────────────+
│                          Raytracer                                 │
│                                                                    │
│   ┌───────────────────────────┐                                    │
│   │    Scene Loading          │──────┐                             │
│   │   - Object Loader         │      │                             │
│   │   - Material Parser       │      ▼                             │
│   └───────────────────────────┘┌───────────────────────────┐       │
│                                │  k-d tree & SAH Builder   │       │
│                                │   for Objects             │       │
│                                │   - SAH Calculation       │       │
│                                └─────────┬─────────────────┘       │
│                                          ▼                         │
│                                ┌───────────────────────────┐       │
│                                │  Collision Detection      │       │
│                                │   - Ray-Object Colliders  │       │
│                                │   - Intersection Points   │       │
│                                └─────────┬─────────────────┘       │
│                                          ▼                         │
│   ┌───────────────────────────┐┌──────────────────────────┐        │
│   │    Adaptive Sampling      ││   Lighting & Shading     │        │
│   │   - Monte Carlo Methods   ││   - Direct Illumination  │        │
│   │   - Halton Sequence       ││   - Indirect Lighting    │        │
│   └───────────────────────────┘│   - Bump Mapping         │        │
│                                │   - Halton Sequence      │        │
│                                └──────────────────────────┘        │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
      │
      ▼
+─────┴───────────────────────────────────────+
│                 Tone Mapping                │
│   - HDR to SDR Convert                      │
│   - Color Correction                        │
└─────────────────────────────────────────────┘

```

### 추가적인 개념들

1. **Phong 모델**
    - 렌더링에서 사용하는 조명 및 쉐이딩 모델로, 확산 반사(diffuse reflection), 환경 반사(ambient reflection), 및 주변 반사(specular reflection)의 세 가지 구성 요소를 사용하여 표면의 색상을 계산합니다.
    
2. **BVH (Bounding Volume Hierarchy)**
    - 객체의 경계 볼륨(hierarchy)를 사용하여 레이 트레이싱 최적화를 수행하는 데이터 구조입니다. BVH는 광선이 부딪히지 않는 객체를 빠르게 제외하여 계산량을 줄입니다.

3. **Adaptive Sampling with Monte Carlo**
    - 잡음을 줄이기 위해 필요한 샘플 수를 최적화하는 기법입니다. Monte Carlo 방법은 무작위 샘플을 사용하여 수치적 계산을 수행하는 통계적 방법론으로, 레이 트레이싱에서는 픽셀의 색상 값을 추정하는 데 사용됩니다.

4. **Tone Mapping for SDR (Standard Dynamic Range)**
    - 레이 트레이싱에서 생성된 고 동적 범위 이미지를 표준 동적 범위(SDR) 디스플레이에 맞게 조정하는 프로세스입니다. 이는 이미지의 색상과 밝기를 조절하여 표시 장치의 제한된 범위 내에서 최적의 결과를 얻기 위해 사용됩니다.










# 레이 트레이싱

## 레이트레이싱의 기본적인 원리

레이트레이싱은 컴퓨터 그래픽스에서 사실적인 이미지를 생성하는 데 사용되는 기법 중 하나입니다. 이 기법의 핵심 아이디어는 다음과 같습니다:

###  광선의 발사

- 카메라(또는 눈)로부터 각 픽셀을 대표하는 광선을 3D 공간으로 발사합니다.
- 이 광선은 보통 카메라의 위치에서 화면을 통과하는 방향으로 발사됩니다.

### 광선의 부딪힘 감지

- 발사된 광선이 3D 공간의 물체와 부딪히는지 확인합니다.
- 부딪히는 경우, 부딪힌 지점의 정보 (예: 위치, 물체의 표면의 노멀 벡터)를 기록합니다.

### 색상의 계산

- 부딪힌 지점에서의 색상은 여러 요인에 의해 결정됩니다. 이 요인에는 물체의 소재, 빛의 강도 및 방향, 광선의 방향 등이 포함됩니다.
- 물체의 소재에 따라 광선은 반사, 흡수 또는 굴절될 수 있습니다.

### 결과 이미지의 생성

- 위의 과정을 모든 픽셀에 대해 반복하여 최종 이미지를 생성합니다.
- 각 픽셀의 색상은 위의 과정에서 계산된 색상으로 설정됩니다.











## 광선 추적 시 물체와 부딪힘을 감지하는 방법

레이트레이싱에서 가장 중요한 부분 중 하나는 광선이 3D 공간의 물체와 어떻게 부딪히는지를 감지하는 것입니다. 이를 위해 다음과 같은 과정이 필요합니다:

### 광선과 물체의 교차 검사

- 각 물체는 그것의 형태나 종류(예: 구, 평면, 삼각형)에 따라 특정한 수학적 표현을 가집니다.
- 광선은 시작점과 방향으로 표현됩니다.
- 물체의 수학적 표현과 광선의 표현을 사용하여 광선이 물체와 교차하는지 계산합니다.

   > **광선과 물체의 교차 검사: 광선과 구의 예**
   > 
   > 구와 광선의 교차를 판별하는 것은 레이트레이싱에서 자주 사용되는 기본적인 예입니다. 구는 중심 \( C \)와 반지름 \( r \)로 정의되며, 광선은 시작점 \( O \)와 방향 벡터 \( D \)로 정의됩니다.
   > 
   > 구와 광선의 교차를 확인하기 위해 다음 방정식을 사용합니다:
   > 
   > $$(t \cdot D + O - C) \cdot (t \cdot D + O - C) = r^2$$
   > 
   > 여기서 \( t \)는 광선이 구와 부딪히는 지점까지의 거리입니다.
   > 
   > 이 방정식을 정리하면 이차 방정식을 얻게 되며:
   > 
   > $$t^2 \cdot D \cdot D + 2t \cdot D \cdot (O - C) + (O - C) \cdot (O - C) - r^2 = 0$$
   > 
   > 이 방정식의 판별식을 계산하여 해의 유무와 종류를 알 수 있습니다. 만약 판별식이 양수라면 두 개의 해가 있어 광선이 구를 두 지점에서 교차합니다. 판별식이 0이라면 광선이 구에 접하는 한 지점에서 교차하며, 판별식이 음수라면 광선은 구와 교차하지 않습니다.
   > 
   > 이 방식으로 광선이 구와 어디서 교차하는지, 그리고 얼마나 많은 지점에서 교차하는지를 알 수 있습니다.


### 부딪힌 지점의 정보 추출

- 광선이 물체와 부딪힌다면, 그 지점의 위치, 물체의 표면에서의 노멀 벡터, 그리고 부딪힌 지점까지의 거리 등의 정보를 추출합니다.

### 가장 가까운 부딪힘 감지

- 하나의 광선은 여러 물체와 부딪힐 수 있습니다.
- 모든 물체와의 부딪힘을 검사하여 가장 가까운 부딪힘 지점을 찾습니다. 이 지점이 광선에 의해 그려질 픽셀의 색상을 결정하는 데 사용됩니다.











## BVH(Bounding Volume Hierarchy)가 필요한 이유

레이트레이싱에서는 광선이 다양한 물체와 교차하는지를 확인해야 합니다. 그런데 렌더링할 장면에 수백, 수천, 수만 개의 물체가 있을 때 각각의 물체와 광선의 교차를 개별적으로 계산하면 많은 연산량이 필요하게 됩니다.

**BVH는 이런 연산량을 최적화하는 방법 중 하나입니다.** BVH는 장면의 물체들을 포함하는 바운딩 볼륨(bounding volume)으로 그룹화하고, 이 볼륨들의 계층 구조를 생성하여, 광선이 어떤 물체와 교차하는지 빠르게 판단할 수 있도록 합니다.

### BVH의 작동 원리

1. **전체 장면을 포함하는 바운딩 볼륨 생성:** 먼저, 전체 장면을 포함하는 바운딩 볼륨을 만듭니다.
2. **물체 분할:** 해당 볼륨 내의 물체들을 두 개의 그룹으로 분할합니다. 이는 일반적으로 물체들의 중심점을 기준으로 공간을 분할하는 방식으로 이루어집니다.
3. **각 그룹에 대해 별도의 바운딩 볼륨 생성:** 분할된 물체 그룹 각각에 대해 별도의 바운딩 볼륨을 생성합니다.
4. **재귀적 분할:** 위의 과정을 재귀적으로 반복하여 BVH의 계층 구조를 생성합니다.

### 주요 바운딩 볼륨의 종류와 사용 케이스

- **AABB (Axis-Aligned Bounding Box)**
  - **모양:** 축에 정렬된 직사각형 상자. 즉, 회전하지 않은 박스 형태입니다.
  - **사용 케이스:** AABB는 계산이 간단하므로 빠른 교차 검사를 할 수 있습니다. 따라서 물체가 회전하지 않을 때나 BVH와 같은 계층적 구조에서 자주 사용됩니다.

      AABB는 축에 정렬된 상자이기 때문에 교차 판별을 위한 계산이 상대적으로 간단합니다.
      1. AABB는 두 벡터로 정의됩니다 최소 점 $min$ 및 최대 점 $max$.
      2. 광선은 시작점 $o$ 및 방향 $d$로 정의됩니다.
      
      교차 검사 알고리즘은 각 축에 대해 광선이 상자와 교차하는 t값의 범위를 찾는 것입니다. 이 t값들의 범위가 겹치면 광선은 상자와 교차합니다.
      $$t_{near} = \frac{\mathbf{min} - \mathbf{o}}{\mathbf{d}}$$
      $$t_{far} = \frac{\mathbf{max} - \mathbf{o}}{\mathbf{d}}$$


- **Bounding Sphere**
  - **모양:** 구 형태로, 중심점과 반지름으로 정의됩니다.
  - **사용 케이스:** 구는 모든 방향으로 동일한 형태를 가지므로 교차 검사가 간단합니다. 물체가 회전하거나 이동할 때 바운딩 볼륨을 업데이트하는 것이 쉬워, 동적인 장면에서 주로 사용됩니다.

      Bounding Sphere는 중심 $c$ 및 반지름 $r$로 정의됩니다. 광선과 구의 교차를 판별하는 것은 광선과 구의 중심 사이의 거리를 계산하여 반지름과 비교하는 것으로 간단화됩니다.
      
      광선의 방향을 $d$, 시작점을 $o$라고 할 때, 광선과 구의 중심 사이의 거리는
      $$\mathbf{m} = \mathbf{o} - \mathbf{c}$$
      광선이 구를 지나가면서 가장 가까워지는 지점을 찾습니다.
      $$t_{ca} = \mathbf{d} \cdot \mathbf{m}$$
      만약 $t_{ca} < 0$이면 광선은 구에서 멀어지고 있습니다.
      구의 중심에서 광선까지의 직교 거리를 찾습니다.
      $$d^2 = \mathbf{m} \cdot \mathbf{m} - t_{ca}^2$$
      1. 만약 $d^2 > r^2$ 이면 광선은 구를 놓칩니다.
      2. 그렇지 않으면, 광선은 구와 교차합니다.
      이렇게 광선이 AABB나 Bounding Sphere와 교차하는지를 판별하는 것은 매우 효과적인 방법들이며 레이트레이싱에서 광범위하게 사용됩니다.

다양한 상황과 필요에 따라 다른 바운딩 볼륨 형태가 사용될 수 있으며, 때로는 두 가지를 조합해서 사용하기도 합니다.

광선 교차 검사 시, 먼저 바운딩 볼륨과의 교차를 확인하고, 교차한다면 해당 볼륨 내부의 물체들과의 교차를 검사합니다. 이렇게 하면 불필요한 교차 검사를 피하고 연산 효율을 크게 향상시킬 수 있습니다.











## 라이팅 쉐이딩 방식

라이팅 쉐이딩은 3D 그래픽스에서 물체의 표면에 빛을 어떻게 반영할지 결정하는 과정입니다. 이 과정은 물체의 재질, 빛의 속성 및 빛의 방향에 따라 달라집니다. 다음은 라이팅 쉐이딩에서 고려되는 주요 구성 요소입니다:

### 1. Ambient Lighting (주변 조명)

- 모든 물체에 일정하게 적용되는 빛입니다.
- 주변 환경의 전체적인 빛을 모사합니다.

### 2. Diffuse Lighting (산란 조명)

- 물체의 표면과 빛의 방향 간의 각도에 따라 달라집니다.
- 물체의 표면이 빛을 모든 방향으로 고르게 산란시키는 특성을 나타냅니다.
- 주로 무광택 표면에 사용됩니다.

### 3. Specular Lighting (반사 조명)

- 물체의 표면에서 빛이 반사될 때 생기는 반짝임을 나타냅니다.
- 빛의 방향, 물체의 표면 방향 및 관찰자의 방향을 모두 고려하여 계산됩니다.
- 주로 광택 있는 표면에 사용됩니다.

### 4. Shadows (그림자)

- 물체가 빛의 경로를 차단하여 다른 물체나 표면에 그림자를 생성합니다.
- 그림자는 물체와 광원 간의 관계에 따라 생성됩니다.

라이팅 쉐이딩은 위의 구성 요소들을 결합하여 물체의 최종 색상을 계산합니다. 이러한 계산은 Phong 모델 또는 다른 쉐이딩 모델을 사용하여 수행될 수 있습니다.









## 고려해야 할 부분들

레이트레이싱에서는 단순히 빛과 물체의 상호 작용만을 다루는 것이 아닙니다. 여러 다른 요소들도 고려되어야 합니다:

### 1. Materials (재질)

- 재질은 물체의 표면이 빛과 어떻게 상호 작용하는지를 정의합니다.
- 각 재질은 다음의 특성을 가질 수 있습니다: 
  - **Diffuse**: 기본 색상이나 텍스쳐
  - **Specularity**: 반사의 강도
  - **Roughness**: 표면의 거칠기
  - **Refractive Index**: 굴절률 (투명한 물체에 사용)

### 2. Textures (텍스쳐)

- 텍스쳐는 물체의 표면에 디테일을 추가하는데 사용됩니다.
- **Bump mapping**: 표면의 디테일을 높이기 위해 사용되는 기법입니다.
- **Checker patterns**: 물체의 표면에 체크무늬 패턴을 추가합니다.

### 3. Reflection and Refraction

- **반사 (Reflection)**: 물체의 표면에서 빛이 반사되는 과정입니다. 거울과 같은 물체에서 발생합니다.
- **굴절 (Refraction)**: 빛이 투명한 물체를 통과하면서 굴절되는 현상입니다. 유리나 물에서 볼 수 있습니다.












## 레이 트레이싱에서의 굴절, 반사 및 흡수

### 1. 반사 (Reflection):
빛이 오브젝트의 표면에서 다른 방향으로 반사되는 현상을 나타냅니다.

$$\[ \text{반사 색상} = \text{레이 색상} \times \text{반사율} \times \text{오브젝트 색상} \]$$

### 2. 굴절 (Refraction):
빛이 투명한 오브젝트를 통과하면서 방향이 바뀌는 현상을 나타냅니다.

$$\[ \text{투과된 색상} = \text{레이 색상} \times \prod_{i} (1 - \text{오브젝트}_i \text{의 반사율} \times \text{오브젝트}_i \text{의 색상}) \]$$

여기서 $\( \prod \)$는 모든 겹친 오브젝트들에 대한 곱셈을 의미합니다.

### 3. 흡수 (Absorption):
빛이 매질을 통과하면서 감소하는 현상을 나타냅니다.

$$\[ \text{흡수된 빛 세기} = \text{레이의 빛 세기} \times e^{-\text{흡수율} \times \text{매질 내에서 이동 거리}} \]$$

여기서 $\( e \)$는 자연 상수입니다.












## 톤 매핑 (Tone Mapping)

레이트레이싱에서 렌더링된 이미지는 종종 HDR (High Dynamic Range) 이미지로 생성됩니다. 그러나 대부분의 디스플레이는 SDR (Standard Dynamic Range)로 이미지를 표시하기 때문에, HDR 이미지의 밝기 범위를 SDR 디스플레이에 맞게 조정해야 합니다. 이 과정을 톤 매핑이라고 합니다.

### 1. 왜 필요한가?

- HDR 이미지는 높은 명암비를 가진 장면에서 밝은 영역과 어두운 영역 모두의 세부 정보를 캡쳐할 수 있습니다.
- 대부분의 표준 디스플레이와 프린터는 이러한 높은 명암비를 표시할 수 없기 때문에, 이미지의 동적 범위를 줄이는 것이 필요합니다.

   #### 동적 범위 (Dynamic Range)
   
   동적 범위는 쉽게 말해 "가장 어두운 부분과 가장 밝은 부분 사이의 명암 차이"를 의미합니다. 
   
   1. **왜 동적 범위는 중요한가?**
       - **인간의 시각**: 우리 눈은 매우 광범위한 명암 차이를 구별할 수 있습니다. 이에 비해, 일반적인 디스플레이나 카메라는 이를 충분히 표현하지 못합니다.
       - **정보의 손실**: 제한된 동적 범위로 명암 차이가 큰 장면을 표현하면, 밝은 부분이나 어두운 부분에서 세부 정보를 잃게 됩니다.
   
   2. **SDR과 HDR의 동적 범위 차이**:
       - **SDR (Standard Dynamic Range)**: SDR은 대략 6-8 스톱의 동적 범위를 가집니다. 즉, 가장 밝은 백색과 가장 어두운 검은색 사이의 명암 차이는 대략 100:1 정도입니다.
       - **HDR (High Dynamic Range)**: HDR는 14-16 스톱 또는 그 이상의 동적 범위를 가질 수 있습니다. 이는 백만 대 1의 명암 비율에 해당합니다. 따라서, HDR는 훨씬 더 넓은 범위의 명암 차이를 표현할 수 있습니다.
         > **스톱** : 밝기의 비트 단계. 8스톱인 경우 픽셀 하나의 R,G,B 컬러당 8비트의 공간을 가지므로, 픽셀 1개당 24비트의 크기를 가짐.
   
   3. **SDR에서의 동적 범위 제한**:
       - SDR 디스플레이나 기존의 카메라 기술은 제한된 동적 범위를 가지고 있습니다. 이로 인해 SDR에서는 자연의 광범위한 명암 차이를 정확히 표현하기 어렵습니다.
   
   4. **HDR의 등장**:
       - HDR는 실제로 눈으로 보이는 것과 같은 광범위한 명암 차이를 재현할 수 있습니다. 그러나, 대다수의 디스플레이는 여전히 SDR 범위로 제한되어 있으므로, HDR 이미지를 SDR에서 볼 수 있게 만드는 '톤 매핑' 과정이 필요하게 되었습니다.
   
   이해하기 쉽게 설명하면, SDR는 마치 흑백 사진처럼 제한된 색상의 명암 차이만 표현할 수 있는 반면, HDR는 컬러 사진처럼 훨씬 더 다양한 색상의 명암 차이를 표현할 수 있습니다. 이로 인해 HDR에서는 자연스러운 빛과 그림자, 그리고 세부적인 정보까지도 훨씬 더 정밀하게 표현할 수 있게 되었습니다.

### 2. 톤 매핑 방법

- **Reinhard Tone Mapping**: 전체 이미지의 평균 밝기를 사용하여 이미지의 스케일을 조정합니다.
- **Photographic Tone Mapping**: 사진의 촬영 매개변수를 모방하여 이미지의 동적 범위를 조정합니다.
- **Filmic Tone Mapping**: 영화의 필름과 같은 미학을 제공하려고 디자인된 방식입니다.

### 3. 고려사항

- 톤 매핑 후에도 장면의 전반적인 느낌과 디테일을 유지하려면 적절한 톤 매핑 기법을 선택해야 합니다.
- 톤 매핑은 이미지의 전반적인 명암, 색상, 밝기를 변화시키므로 결과물에 대한 아티스트의 의도와 관점을 고려해야 합니다.

톤 매핑은 레이트레이싱 렌더링의 결과물을 최종적으로 시각화할 때 중요한 과정입니다. 이를 통해 아름답고 현실적인 이미지를 생성할 수 있습니다.










# 최적화

## k-d 트리와 SAH를 이용한 레이 트레이싱 최적화

### 1. k-d 트리의 기본 개념
- **k-d 트리**는 공간을 분할하는 이진 트리입니다.
- 각 노드는 특정 축을 기준으로 공간을 두 부분으로 나눕니다.
- 트리의 깊이가 증가할 때마다 분할 축이 변경됩니다 (예: x, y, z 순환).

### 2. SAH (Surface Area Heuristic)
- **SAH**는 바운딩 볼륨의 표면적을 기반으로 분할의 효율성을 평가하는 방법입니다.
- **비용 함수**: 
  $$\[
  \text{Cost} = \frac{A_1}{A_{\text{total}}} \times N_1 \times C_{\text{int}} + \frac{A_2}{A_{\text{total}}} \times N_2 \times C_{\text{int}} + C_{\text{trav}}
  \]$$

  - $\( A_1, A_2 \)$: 각각의 바운딩 볼륨 면적
  - $\( N_1, N_2 \)$: 각 바운딩 볼륨 내의 오브젝트 수
  - $\( C_{\text{int}} \)$: 교차 테스트 비용
  - $\( C_{\text{trav}} \)$: 노드를 순회하는 비용

### 3. 트리 구축
- 각 단계에서 SAH를 사용하여 최적의 분할 위치를 찾습니다.
- 트리의 깊이가 너무 깊어지거나, 분할 후 한쪽에 오브젝트가 없게 되거나, 전체 오브젝트 수가 특정 임계값 이하로 줄어들면 분할을 중단합니다.

### 4. 레이 트레이싱 최적화
- k-d 트리를 사용하면 광선이 '만나지 않는 바운딩 볼륨'에 속한 오브젝트들은 교차 테스트에서 제외됩니다.
- 이로 인해 광선은 남아있는 오브젝트와만 교차 테스트를 수행하게 되어 연산 효율이 크게 향상됩니다.







## 적응적 샘플링 (Adaptive Sampling)

- **정의**: 렌더링에서 모든 픽셀에 동일한 양의 계산 노력을 사용하는 대신, 더 많은 노력을 필요로 하는 픽셀에 더 많은 샘플을 할당하는 기법.
- **과정**:
  1. **초기 샘플링**: 모든 픽셀에 대해 기본 샘플 수행. 이때, 랜덤한 방향으로 레이를 발사하여 샘플링.
  2. **분산 평가**: 초기 샘플링을 통해 각 픽셀의 색상 값 분산 계산. 분산은 픽셀의 색상 값들이 얼마나 서로 다른지를 나타내는 지표.
  3. **적응적 샘플링**: 높은 분산을 가진 픽셀에 추가 샘플 할당. 이때도 랜덤한 방향으로 레이를 발사하여 샘플링.

### 몬테 카를로 방법 (Monte Carlo Method)

#### 1. 기본 원리
- 몬테 카를로 방법은 **무작위 샘플링**을 통해 수치적 결과를 추정하는 통계적 방법입니다.
- 주어진 함수의 기대값을 추정하기 위해 사용되며, 다차원 공간에서의 적분 문제를 해결하는 데 특히 유용합니다.

#### 2. 수식적 표현
- 어떤 함수 $\( f(x) \)$의 기대값은 다음과 같이 정의됩니다:
  $$\[ E[f(x)] = \int f(x) p(x) dx \]$$
  여기서 $\( p(x) \)$는 확률 밀도 함수입니다.
- 몬테 카를로 방법을 사용하여 기대값을 추정:
  $$\[ \int f(x) p(x) dx \approx \frac{1}{N} \sum_{i=1}^{N} f(x_i) \]$$
  여기서 $\( x_i \)는 \( p(x) \)$에 따라 무작위로 선택된 샘플입니다.

#### 3. 중심극한정리 (Central Limit Theorem)
- 몬테 카를로 방법의 정확도는 중심극한정리에 기반합니다.
- 큰 수의 샘플을 사용하면, 함수의 평균값은 정규 분포에 근사하게 됩니다.

#### 4. 장점 및 단점
- **장점**: 복잡한 문제나 다차원 공간에서의 적분 문제를 간단하게 해결할 수 있습니다.
- **단점**: 샘플 수가 적을 경우 노이즈가 발생할 수 있으며, 높은 품질의 결과를 위해서는 많은 샘플 수가 필요합니다.

### 몬테 카를로 방법을 이용한 적응적 샘플링

- **목적**: 레이 트레이싱에서 노이즈를 줄이고, 렌더링의 효율성과 품질을 향상시키기 위해 사용.
- **방법**: 
  - 각 픽셀에서 랜덤한 방향으로 레이를 여러 번 발사하여 색상 값을 샘플링.
  - 샘플링된 색상 값들의 평균을 통해 해당 픽셀의 최종 색상 값을 결정.
  - 몬테 카를로 방법의 핵심 원리인 랜덤 샘플링을 통해 현실적인 렌더링 결과를 얻음.
 








## 할튼 시퀀스 (Halton Sequence)

### 개요
할튼 시퀀스는 **낮은 이산도(low-discrepancy) 시퀀스**로서, 고차원 공간에서 균일한 샘플 분포를 생성하는 데 유용합니다. 

### 특징
- **균일한 분포**: 전통적인 랜덤 샘플링보다 더 균일하게 분포된 샘플을 생성합니다.
- **노이즈 감소**: 렌더링에서 낮은 이산도 시퀀스를 사용하면 노이즈를 줄이는 효과가 있습니다.

### 사용 방법
1. 서로소인 소수 집합(예: 2, 3, 5, 7...)을 선택합니다.
2. 각 소수를 기반으로 샘플을 생성합니다.
3. 생성된 샘플들을 조합하여 고차원 샘플을 얻습니다.

### 예시
렌더링에서 광선 추적 또는 셰이딩 샘플링과 같은 Monte Carlo 기반의 테크닉에 사용되어 더 나은 결과를 얻을 수 있습니다.









## 부동소수점 정밀도

- **목적**: 필요한 만큼의 정밀도를 선택하여 연산 성능을 최적화합니다.
  
- **방법**:
  1. 단정밀도 (`float`)는 일반적으로 게임과 그래픽스에서 사용되며 대부분의 경우에 충분합니다.
  2. 배정밀도 (`double`)는 더 높은 정밀도가 필요한 애플리케이션(예: 과학 계산, 핀테크)에서 사용됩니다. 연산 속도는 일반적으로 단정밀도보다 느리지만, 많은 현대 CPU들은 배정밀도 연산도 빠르게 처리할 수 있습니다.
 










## 좌표 시스템 선택

### 좌표계의 종류와 선택 이유

- **직교 좌표계 (Cartesian Coordinates)**:
  - **선택 이유**: 벡터 연산이 간단하고 직관적입니다. 대부분의 그래픽 연산에서 기본적으로 사용되는 좌표계입니다.
  - 물체의 위치, 방향 및 크기를 쉽게 표현하고 연산할 수 있습니다.

- **주면 좌표계 (Cylindrical Coordinates)**:
  - 주로 회전 대칭을 가진 문제에 적합합니다.
  
- **구면 좌표계 (Spherical Coordinates)**:
  - 3D 공간에서의 방향을 표현할 때 유용하게 사용됩니다. 
  - 빛의 방향, 사운드의 방향 등을 표현할 때 사용됩니다.

      #### 직교 좌표계 (Cartesian Coordinates) 선택하기
      
      - **목적**: 레이 트레이싱에서의 연산의 간결성과 정확성을 확보하기 위함.
      
      - **이유**:
        1. **간단한 연산**: 직교 좌표계에서의 벡터 연산은 직관적이며 계산이 간단합니다.
        2. **표현의 용이성**: 3D 공간 내에서 물체의 위치, 방향, 그리고 크기를 쉽게 표현할 수 있습니다.
        3. **레이의 교차점 계산**: 레이와 물체의 교차점을 찾는 것은 레이 트레이싱의 핵심 연산 중 하나입니다. 이 교차점 계산은 직교 좌표계에서 더 간단하고 정확합니다.
        4. **일반적인 관례**: 대부분의 그래픽 라이브러리와 알고리즘은 직교 좌표계를 기본으로 합니다.
      
      - **추가적인 고려사항**:
        1. **좌표 변환**: 다양한 좌표계 간의 변환이 필요할 수 있습니다. 직교 좌표계와 다른 좌표계 (예: 주면좌표, 구면좌표) 간의 변환에 대한 이해가 필요합니다.
        2. **좌표축의 일관성**: 프로젝트 전반에 걸쳐 사용되는 좌표축의 방향과 기준을 일관되게 유지하는 것이 중요합니다.

### 좌표축의 통일성

- **목적**: 다양한 연산에서의 일관성과 복잡성을 줄이기 위해.
- **방법**: 프로젝트 전반에 걸쳐 동일한 좌표축을 사용하여 연산의 복잡성을 줄이고 코드의 가독성을 향상시킵니다.

### 좌표 변환 최적화

- **목적**: 좌표 시스템 간의 변환은 추가적인 연산 비용이 발생합니다. 이를 최소화하려면 초기 단계에서 좌표 시스템을 명확히 정의하고 필요한 변환만 수행하는 것이 중요합니다.
- **방법**: 변환은 필요한 경우에만 수행하며, 변환의 횟수와 복잡성을 최소화하기 위해 초기 설계 단계에서 계획을 세웁니다.










## Bump Mapping

### 개요
Bump Mapping은 3D 모델의 실제 기하학적인 구조를 변경하지 않으면서 표면의 디테일을 향상시키기 위한 기술입니다. 이 기술은 표면의 미세한 높낮이나 주름을 시각적으로 재현하기 위해 사용됩니다.

### 원리
Bump Mapping의 핵심은 **Normal Map**입니다. Normal Map은 RGB 채널을 사용하여 각 픽셀에서의 법선 벡터의 방향을 인코딩합니다. 이렇게 인코딩된 벡터는 기본 표면의 법선과 결합되어, 광선이 표면에 부딪힐 때 반사 각도의 계산에 사용됩니다.

### 구현
1. **Normal Map 생성**: 툴(예: Photoshop, GIMP, Blender)을 사용하여 높낮이 정보를 바탕으로 Normal Map을 생성합니다.
2. **Shader에서의 사용**: Shader에서는 Normal Map에서 추출한 벡터를 사용하여 기본 표면의 법선을 조정합니다.
3. **반사 광선 계산**: 조정된 법선을 사용하여 광선의 반사 각도를 계산하고, 이를 바탕으로 조명, 반사 등의 효과를 구현합니다.

### 특징
- Bump Mapping은 표면의 디테일을 향상시키면서도 추가적인 기하학적 복잡도를 가져오지 않습니다.
- 효과를 최대한 잘 표현하기 위해서는 충분한 샘플링 수와 고해상도의 Normal Map이 필요합니다.
- Bump Mapping은 다양한 조명 환경에서 표면의 디테일을 향상시킬 수 있으며, 특히 몬테카를로 방법과 같은 확률적인 방법을 사용할 때 효과적입니다.

**참고**: Bump Mapping은 표면의 디테일을 시각적으로 재현하기 위한 기술이기 때문에, 실제 표면의 기하학적인 변경은 발생하지 않습니다. 기하학적인 변경을 원한다면 Displacement Mapping과 같은 다른 기술을 고려해야 합니다.










